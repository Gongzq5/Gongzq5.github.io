<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Raynal-Schiper-Toueg因果序保证算法]]></title>
    <url>%2Fposts%2FRaynal-Schiper-Toueg%E5%9B%A0%E6%9E%9C%E5%BA%8F%E4%BF%9D%E8%AF%81%E7%AE%97%E6%B3%95-2019-07-07%2F</url>
    <content type="text"><![CDATA[又是一篇没人写的算法，这门课没得参考就很尴尬 是一种分布式环境下的因果序保证算法 Pre: 消息通道，因果序 因果序是什么一个消息通道保证因果序，意味着当两个消息的发送有依赖关系时，接收也要有依赖的关系，即：逻辑先发的一定会在逻辑上先收到。 数学一点，是这样的： 对任意两个发向同一进程的消息$m{ij}$和$m{kj}$ ，假设$Send(m{ij})→Send(m{kj})$，则$Recv(m{ij})→Recv(m{kj})$ 也就是说，发送是有逻辑依赖的关系，在接收时也是按照逻辑依赖的顺序接收的。 除了因果序，消息通道还有以下的顺序 FIFO模型：信道运行为一个先进先出的队列模型 非FIFO模型：信道为一个集合，发送者向里面添加消息，接受者在里面移除消息，添加和移除是无序的 因果序应用：三副本机制 不再罗嗦了，课件非常清晰 保证因果序的基本思路基本思路很简单 每条消息M都携带一条日志，保存了所有因果关系上在M之前的消息； M到达目的地是，先缓存自己，然后检查自己日志里的消息是否都到达了这个目的地（只检查目的地也是这里的就可以了）； 如果满足这个要求，那么就可以把自己交付给这个目的进程了；否则要进入等待的状态； 这里有一点小问题，如果记录因果上先于M的消息呢？ 很简单，如果m2依赖于m1，m3依赖于m2。那么m2携带的日志里有m1；而m3只需要复制m2的日志，再加入m2就可以了。 也就是说，将所有已发送的消息沿着因果路径不断转发就可以了。 Raynal-Schiper-Toueg算法 注意：这个算法要求FIFO通道 算法思想基本思路是对我们上面所说的进行了简化，上面的描述中，记录了所有的消息，带来了很大的冗余。 我们考虑在FIFO通道下。当m2收到时，m1一定也已经收到了。进一步思考，发送者要求这条消息依赖于之前的，i-&gt;j的10条消息，如果j进程发现自己当前已经收到了来自i的20条消息，那么可以肯定，要求的那10条消息肯定包含在我们已收到的20条消息里（FIFO的特性，i-&gt;j通道上不会出现乱序）。 也就是说，我们只需要记录我们依赖的通道上的消息数量就可以了，这样就简化了传递的消息复杂度。 算法详述算法详细描述如下： Send[j,k]记录本进程所知的进程j发送到进程k的消息数量 DELIV[j]记录由进程j发来的、已经Deliver到本进程的消息数 发送消息时： i-&gt;j发送消息，表明所有依赖的消息是自己当前的SENT矩阵，附带在消息里发送，然后SENT[i, j]++； 接受消息时： j-&gt;i发送消息，接收到j的ST矩阵，就是当前消息的依赖，我们判断我们收到的消息数量（x是每个进程编号） DELIV[x] \geq ST[x, i]满足时，确认已收到了所有依赖的消息 然后对SENT按位取max，自身和当前消息的依赖都要满足； 然后DELIV[j]++，这是接收到的来自j的消息数量；]]></content>
      <categories>
        <category>分布式计算</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步Floyd-Warshall算法]]></title>
    <url>%2Fposts%2F%E5%BC%82%E6%AD%A5Floyd-Warshall%E7%AE%97%E6%B3%95-2019-07-06%2F</url>
    <content type="text"><![CDATA[同步算法同步的Floyd-Warshall算法还是很简单的，算法过程如下 也很好理解，就是对于每条路径 (s-&gt;t)，寻找他们经过的最近的那个中间点（pivot），目标是找到一个s-&gt;pivot-&gt;t的路径比当前确定的s-&gt;t的路径还要近。所以就不停的测试，从s到t的路径变成s-&gt;1-&gt;t，s-&gt;2-&gt;t……会不会近一点…… 更深入来说，其实是一种动态规划的思想，先找到任意两个节点通过节点1的最短长度，然后再找通过节点2的最短长度=min{using 1, 2} 可以去百度一下，同步算法的博客有很多，讲的比我详细的多，直接搜floyd-warshall就可以了 异步算法异步算法就比较奇怪了，首先我们使用同步算法的依据是LENGTH这个变量保存了所有的距离信息，也就是说，全局的距离信息都是已知的，然而到了异步版本，每个进程都只知道自己到各个节点的距离（标记为LEN，而且这个最近的一跳也要记下来，标记为PARENT），而不知道其他两个节点的距离，所以我们需要处理，让每个进程知道全部的消息。 还是要按照同步算法的思想来处理，所以循环的最中心最重要的变量是pivot到各个节点的距离，所以我们可以将pivot节点的LEN信息对全网进行广播，所以其他节点就可以根据此个pivot的信息对自己的变量进行更新了。 草草的总结了一下，大致是这个意思的 依次用每个节点作为中心点pivot 对于每个邻居节点nbh 如果当前节点到pivot的最短路的下一跳是nbh，那么给nbh发送一个intree(pivot) 如果不是，那给nbh发送一个notintree(pivot) 等待每个邻居节点nbh的intree和notintree消息 如果当前节点和pivot已经找到了路径，那么 如果pivot不是自己，就从到pivot的下一跳节点请求PIVOT_ROW 对每个nbh邻居节点 如果收到了nbh的INTREE消息 如果pivot是自己，给nbh发送自己的len 如果不是，就发送自己存的PIVOT_ROW给nbh 当前就知道了自己到pivot的距离，pivot到其他节点的距离，可以更新路径 解释还是集中式的算法一样，用每个节点作为pivot进行考虑，程序开始时，所有节点都给自己的邻居节点发送INTREE和NOTINTREE消息，表明自己想要到达pivot节点，需要（或不需要）下一跳经过这个邻居节点。 然后每个节点都进入了await状态，直到收到各自的所有邻居节点发来的消息。 然后程序继续执行 如果LEN[pivot]不是无穷，也就是当前节点已经找到了和pivot相连的一条路径 如果没找到的话，那么说明当前节点和pivot不相连，也就没有更新路径的可能性了，在当前pivot阶段，程序可以结束了，等待下一次循环 继续进行判断，如果pivot是自己，那么自己的LEN就是pivot_row这个变量。如果不是呢，那么就要想办法获取这个变量（pivot节点到各个节点的最短距离），所以从离pivot更近的一个节点进行寻找，也就是说从Parent[pivot]进行寻找，等待它给我们发送一个pivot_row的信息。这里又要进入await状态了，没有这个消息我们确实寸步难行。 得到之后，我们遍历每个邻居节点nbh。如果收到了nbh的intree消息，那么说明我们当前节点是nbh到pivot节点的下一跳，也意味着我们要给它发送pivot_row消息（对照上一段），所以我们给他发pivot_row，同样，如果自己就是pivot，那就发自己的len就可以了，如果自己不是，那就发自己收到的pivot_row（上一段收到的）。 这样操作结束后，当前节点通知了所有其他需要通知的节点PIVOT_ROW消息，所以理论上来说，让所有节点都收到pivot_row消息的操作已经圆满了（至少分配给自己节点的任务已经完成了），可能需要等一等，就可以让所有节点知道合理的pivot_row了。 当然我们的当前节点没有必要等待，它可以直接进行下一步了，那就是更新自己的LEN变量（根据pivot_row和len，就相当于同步算法的length[s, t]和length[pivot, ...]） 这样，就可以让所有节点生成一棵全源最短路的图了。 总结本质上来说，这个和集中式的算法没有区别，但是为了不同进程的同步，我们加入了很多处理同步的内容，需要耐心但不是特别难。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nova 源码学习笔记]]></title>
    <url>%2Fposts%2FNova-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2019-06-26%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Nova cli 源码学习笔记]]></title>
    <url>%2Fposts%2FNova-cli-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2019-06-26%2F</url>
    <content type="text"><![CDATA[最终目标： 为Nova开发一个小组件！ 记录自己摸索的过程啦，持续更新直到完成 先看看书，再看看github上Openstack的组织仓库，找到了两个仓库 Nova：https://github.com/openstack/nova，Nova的大仓库，主要的功能实现应该都在这里了 Nova client：https://github.com/openstack/python-novaclient，命令行 cli （应该主要是Nova命令）的客户端 感觉应该是最重要的需要看的仓库了，可以看到调用命令行的过程，然后继续看看，还有一些可能会有用的仓库 Openstack client：https://github.com/openstack/python-openstackclient，命令行（Openstack命令）的客户端 Horizon：https://github.com/openstack/horizon，Horizon的实现里，想必也有不少的基于 Http 请求的Nova API的调用实例 之前已经看过了Nova的代码了，感觉没有太多的涉及API的部分，直接去看Nova Client部分吧 下载Nova client的代码，发现了 doc文件夹，打开以后发现和网站提供的文档是一致的， 就直接在网站上看了 https://docs.openstack.org/python-novaclient/latest/reference/api/index.html 网站上来就是代码了 12&gt;&gt;&gt; from novaclient import client&gt;&gt;&gt; nova = client.Client(VERSION, USERNAME, PASSWORD, PROJECT_ID, AUTH_URL) 幸好有之前跟着官网一步一步配置的经验，不然看着这参数肯定一脸懵。 想起来之前官网的配置教程给了一个 admin-openrc 的文件使用，每次调用 cli API 之前都要使用 . admin-openrc 激活一下。 找到自己的虚拟机，打开admin-openrc看一下，发现给了不少的参数 12345678export OS_PROJECT_DOMAIN_NAME=Defaultexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_NAME=adminexport OS_USERNAME=adminexport OS_PASSWORD=****export OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2 激活环境变量，测试一下使用nova flavor-list，正常输出。 把这些放到文档给的代码里试验一下，发现是不可以的，报错了，明显是我的权限验证有问题。 从源代码开始分析一下，全文搜索OS_PROJECT_，5个文件中存在，除了doc和test中以外，就只剩下shell.py这个文件了，果然，这个文件从环境中读取了OS_PROJECT_...的变量。同时发现这个文件存在main函数，一定也是全程序的执行入口。从这个文件一路按图索骥，找到了熟悉的client.Client()调用，然后惊喜的发现，居然有两个client？？？还好注释写的明白，第一个声明只是为了确定version，第二个声明才是真正的声明。 遇到了一个函数 importutils.import_class(…)，从根目录水平导入一个类，作为一个变量来使用，python真是博大精深啊…… 源码： 123&gt; return version, importutils.import_class(&gt; ​ "novaclient.v%s.client.Client" % version.ver_major)&gt; &gt; [Update]： 误会了，原来这是 Openstack 自己完成的一个函数，源码大致是这样操作的： getattr(sys.modules[mod_str], class_str) 试验了一下，和import语句导入的模块无差，算是一种动态导入的方式了 发现目录下只存在v2的子目录，因此看来是不存在使用 verison=2.x 这种操作了 现在思考一下，还有一个问题悬而未决，是这个程序是如何监听的，思考了一番也没有找到，只有一行代码感觉是相关的 1args.func(self.cs, args) 应该是自己给args加的属性，具体加了什么函数，还是不是很明确，应该是在这里执行的命令。 猜测nova命令就是使用了shell.py的命令解析，所以试着直接运行 shell.py并加命令行参数，果然是可以的。 然后再shell.py里简单的加了输出，没有问题；再然后在Client函数里加Log，发现没有输出，找了半天原因，发现是导入模块时，直接导入了已安装的包的模块，而不是当前目录下的模块，强行改造源代码，加入了输出的部分，一切正常了。 现在回头，从之前我们写的flavor-list这个命令开始进入程序分析 我们全项目匹配flavor list类似的关键字，找到了一个函数，do_flavor_list，位于novaclient-&gt;v2-&gt;shell.py，尝试着加一下log，输出了，没有问题，我们跟着这个函数的调用继续研究。 1234567def do_flavor_list(cs, args): """Print a list of available 'flavors' (sizes of servers).""" if args.all: flavors = cs.flavors.list(...) else: flavors = cs.flavors.list(...) _print_flavor_list(cs, flavors, args.extra_specs) 可以看到，关键函数是 cs.flavor.list()，我们去找一下flavor的定义（在v2-&gt;client.py) 1self.flavors = flavors.FlavorManager(self) 继续去看FlavorManager，这里可以直接右键跳转了，发现FlavorManager的list()方法是处理了一些参数，然后转发给了_list这个方法。这个类里没有_list方法了，继续去基类找，一路找到base.py的Manager类，这个类有_list方法，获得重要参数的方法是： 1234if body: resp, body = self.api.client.post(url, body=body)else: resp, body = self.api.client.get(url) 看一下api的定义，发现要一路回到self.flavors = flavors.FlavorManager(self)，这个api就是client本身，找到client实例的client属性，发现是个httpclient对象，用_construct_http_client方法构造，具体的操作流程就是发送了一个请求给/flavors，然后获得返回值，一路返回，也就是这个api的操作流程了。 基本上大部分的API都可以通过这样的流程找到对应的位置，在此也就不再赘述啦…… 下面该去看Nova的源码了，看一下这个服务端到底是如何建立起来的]]></content>
      <categories>
        <category>Openstack</category>
      </categories>
      <tags>
        <tag>Openstack</tag>
        <tag>Nova</tag>
        <tag>云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use sequelize ORM in Nodejs]]></title>
    <url>%2Fposts%2FUse-sequelize-ORM-in-Nodejs-2019-06-23%2F</url>
    <content type="text"><![CDATA[记录一下如何使用Sequelize框架，包括如何放在项目里进行组织，如何使用框架进行CRUD的操作 开始之前先讲讲我的开发配置 语言：Nodejs 后端框架：KOA2 数据库： MySQL 5.6 选择一个ORM框架如何选择是个大问题，百度了一些，大家推荐的基本是这四种 TypeORM：读了读代码，是用typescript写的，风格上和Java非常像，用注解什么的，感觉还不错，备选 ORM2：看了几篇博客，好像有点小坑，还是算了 Knex：推荐使用Bookshelf.js，支持Oracle，放弃了，毕竟已经确定了是用 KOA2 （类似express的风格了） Sequelize：这个应该是应用最广泛的了，看了看文档也很齐全，中文文档就有不下五六个版本，应该资源是不缺的，而且相比起其他的更像是javascript，就是他了！ 基本大家都实现了Promise，所以基本都可以使用async / await Sequelize又是开始之前 一篇翻译的不错的中文文档：https://github.com/demopark/sequelize-docs-Zh-CN 官方给的详细的API参考：http://docs.sequelizejs.com/identifiers 一定要善用后边这个文档，我是后期才使用这个文档，感觉前边吃了不少亏 Get Started安装12npm install --save sequelizenpm install --save mysql2 # 可能要自己选择具体的数据库驱动，我们是MYSQL，就是这个了 建立数据库连接123456789101112131415161718192021222324const Sequelize = require('sequelize');const sequelize = new Sequelize('database', 'username', 'password', &#123; host: 'your ip address', dialect: 'mysql', // Or mariadb, postgres, mssql ... operatorsAliases: false, dialectOptions: &#123; // 字符集 charset: "utf8mb4", collate: "utf8mb4_unicode_ci", supportBigNumbers: true, bigNumberStrings: true &#125;, pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;, timezone: '+08:00' //东八时区&#125;);module.exports = &#123; sequelize&#125;; 可以使用 .authenticate() 函数来测试连接. 12345678sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.'); &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err); &#125;); 建表和使用说时迟那时快，马上就到了最重要的一步，建表。话不多说直接上代码。 123456789101112// from task_table.jsmodule.exports = function(sequelize, DataTypes)&#123; return sequelize.define('task',&#123; task_id:&#123; type:DataTypes.INTEGER, primaryKey:true, allowNull:false, autoIncrement:true &#125;, ...... );&#125;; 这就完成了一个表的模型的定义，到使用时，我们要在其他文件中 require这个文件，如下： 1234567const TaskTable = sequelize.import('task_table');// 用查询举例async function searchTaskByID(task_id) &#123; return await TaskTable.findByPk(task_id); // find by primary key&#125; 使用时调用这个函数就可以返回根据id查询到的task对象了。 这样，最简单的使用就完成了，具体的建表和表查询的API咱们等下继续讨论。 建表之前我们已经给出了建表的一段简单的代码，现在具体的看看还可以提供什么 freezeTableName12345678return sequelize.define(&apos;user&apos;,&#123; id: &#123; type:DataTypes.INTEGER&#125;,&#125;, &#123; // 如果为 true 则表的名称和 model 相同，即 user // 为 false MySQL创建的表名称会是复数 users // 如果指定的表名称本就是复数形式则不变 freezeTableName: true&#125;); 如果为 true 则表的名称和 model 相同，即 user，为 false MySQL创建的表名称会是复数 users，如果指定的表名称本就是复数形式则不变 type详情请参考API文档里关于DataTypes类的说明 包含了一些主要使用的数据类型，我们常用的有Integer, Float, Char(), Text, Date ...，例子可以看上边的定义 访问器和设置器每个属性都可以设置 get(), set()函数，可以方便的获取一些格式化的值，比如对于时间的处理，由于不同的时间有不同的表示格式，我们可以在访问器这个级别来使用库来转换这个格式 123456updatedAt: &#123; type: DataTypes.DATE, get() &#123; return moment(this.getDataValue('updatedAt')).format('YYYY-MM-DD HH:mm:ss'); &#125;&#125; 这样，我们拿出来的值就不是标准时间 ****T****Z这种奇怪的格式，而是形如 YYYY-MM-DD HH:mm:ss 的时间了 外键约束使用 reference 可以指定外键，如下： 123456789team_id:&#123; type:DataTypes.INTEGER, allowNull:false, references: &#123; model: 'team', key: 'team_id', deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE &#125;&#125;, deferrable是指定依赖的关系，比如添加时外部表没有该键如何处理，删除时是否要级联删除等……请查看文档的详细介绍 列属性定义的一些其他参数 参数名 可选取值 解释 备注 primaryKey ` true false` 主键 allowNull ` true false` 可以为空 autoIncrement `true false` 自增属性 查询从where开始Sequelize 提供了不少查询的API，可以直接使用，比如 123456let task = await Task.findAll(&#123; where: &#123; task_id: 1 &#125; attributes: ['task_id']&#125;)); 相当于SELECT task_id FROM task WHERE task_id=1，返回值是一个数组，里边包含了0个或多个 Sequelize 的 model 对象（也可以理解为查询结果转换为的Json对象） 基本上使用就是通过 where 语句进行限定，如果想要使用And | Or ，可以使用官方提供的Op类，如下： 12345678await Task.findAll(&#123; where: &#123; task_id: &#123; [Op.or]: [1,2,3,4] &#125; &#125; attributes: ['task_id']&#125;)); 我们回到这个返回值来看，这个对象还是和普通的Json不太一样，sequelize 为我们包装了不少东西，比如可以提供get()的访问。 关联查询感觉这是一个比较麻烦的地方，关键是资料还贼少，大概谢谢自己总结的一些地方 先上官方文档 建立关联关联要使用到几个关系，分别是BelongsTo, BelongsToMany, HasMany, HasOne 其中 BelongsTo和HasOne对应于1：1的关联 而HasMany对应于1：m的关联 而BelongsToMany对应于n:m的关联 1:1我们可以预先定义这个关联 12UserInfo.belongsTo(User, &#123;foreignKey: &apos;username&apos;&#125;)// 或 User.hasOne(UserInfo, &#123;foreignKey: &apos;username&apos;&#125;) 这两种写法都会给 UserInfo 加入一列，作为外键，指向 User 的username 上，当然如果需要这个添加反映到数据库上，需要使用 Sequelize.sync()才可以 完成以上这一步之后，当你获得从 findAll 的API得到的 UserInfo 对象时，可以使用 getUsers() 这样的函数，来获取和他关联的 user 对象。 1:m和上边差不多，只是换成了 hasMany 而已 m:n这个是面向多对多的关联的，比如用户加入小组，需要在用户和小组之间建立一个联系，大概像这样： 123| id | username | team_id | ... || 0 | user1 | 1 | ... |... 我们可以使用 BelongsToMany 这个关联，需要提供一个through的表，比如： 1Team.belongsToMany(User, &#123;through: Members, foreignKey: 'team_id', target_key: 'username'&#125;) 需要预先定义一个 Members 的 Model，可以不写东西，会自动添加两边的主键进去，也可以自己先定义一些其他的需要的列，比如状态什么的。 使用关联进行查询查询时需要使用的是include方法，如下： 1234567Task.belongsTo(User)return await Task.findAll(&#123; where: &#123; ... &#125;, include: [&#123; model: User &#125;]&#125;) 相当于先在关联的外键上做一个Join ，然后进行查询。可以看到 include 提供的是一个数组，所以是可以提供多个表级联的查询的。 可能每次在前边写 belongsTo 感觉比较奇怪，一种可选的写法是： 123456return await Task.findAll(&#123; where: &#123; ... &#125;, include: [&#123; association: Task.belongsTo(User) &#125;]&#125;) 也是差不多的 Update、Delete、Create这三个就直接一起讲了，没太大区别 12345678910111213141516171819models.TR.create(&#123; username: username, task_id: task_id, state: models.status_code.tr.WAITING_TO_BE_DONE&#125;)models.Task.update(&#123; state: models.status_code.task.ACCEPETED_AND_DOING&#125;, &#123; where: &#123; task_id: task_id &#125;&#125;) TR.destroy(&#123; where: &#123; task_id: task_id &#125;&#125;) 具体参数写了什么不需要管，反正大概就是这个意思啦，要注意删除用的是 destroy sql 聚合函数聚合函数是指 count 啊什么的，比如： [[sequelize.fn(&#39;COUNT&#39;, sequelize.col(&#39;hats&#39;)), &#39;no_hats&#39;]]，调用了count函数，对hats 列进行计数，并将结果存为no_hats，我们可以在include或findAll的参数里直接使用这个。 使用原始SQL语句到现在肯定有同学发现了，还是不灵活，有不少操作很难完成，幸好我们可以直接使用 sql 语句进行查询，如下： 123456await sequelize.query( "SELECT * FROM `task` where `task_id` NOT IN (SELECT `task_id` FROM `teamtask`) AND `publisher` = \'" + org_name + "\'", &#123; type: sequelize.QueryTypes.SELECT&#125; ).then(result =&gt; &#123; return result &#125;); 这里当然是可以进行参数绑定的，我就直接裸加了，如果需要参数绑定请自行百度一下吧哈哈（当然这个语句还是可以用两个awiat完成的，我没什么例子了随便写写啦） 一些小tips一是使用redis进行缓存，这个可以单独去搞，也就不在这里赘述了。 除此以外，我们可以尝试着让一些查询尽可能的并行化 Promise.all这里要提到一个工具：Promise.all([])，举例如下： 我们接受任务后需要对任务的状态进行修改，即这样的需求： 12await models.TR.create(...);await models.Task.update(...); 这就是2个await语句，我们可以把这个包装一下： 1234let result = await Promise.all([ models.TR.create(...), models.Task.update(...)]) 相当于把两个串行改成了并行的，还是可以省不少时间的，特别是访问多了以后 要注意每个异步语句都是会立即返回一个promise对象的，因此我们可以用循环运行所有的这些操作，并将返回值存储起来，然后放到Promise.all()的参数中，等待其完成 Transaction把所有的时间打包作为一个事务提交，理论上应该免去了网络的时延啊，虽然我没有用，但是应该是一个很好的选择。 目录结构我们项目使用的目录结构大致如下： 12345root├─......├─controllers├─models└─tables controllers负责处理router模块处理的URL后分发的请求，对参数进行分析，处理主要的业务逻辑部分； models负责与数据库进行交互，使用我们上面提到的这一堆API进行实现； tables负责建表的语句； 以上三个文件夹有明显的分层，存在由上到下的调用的依赖，同级之间尽量不发生依赖关系，也不会出现依赖上级代码的情况。如果可以的话，我也推荐在每个文件夹写一个总的导出的文件，到上一层时，使用这个文件进行导入，而不是导入每个下层文件夹里所有的文件，这样也可以保证所有的建表语句会在开始时运行，而不会出现最后发现有个表没有用到的情况。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>sequelize</tag>
        <tag>nodejs</tag>
        <tag>ORM</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rasterization-Bresenham, scan line method]]></title>
    <url>%2Fposts%2FRasterization-Bresenham%2C%20scan%20line%20method-2019-03-20%2F</url>
    <content type="text"><![CDATA[光栅化算法，主要是： DDA 画直线算法； Bresenham 快速画直线算法； Bresenham 画圆算法； Edge Equation 三角形填充算法； 实现结果先看效果啦，分别是使用Bresenham算法画直线、圆、并使用Edge Equation算法填充三角形的效果 DDA想了想还是先提一句DDA吧，这个也是经典了 DDA就是简单的数值微分然后拟合的算法，它的原型大致过程如下： 给两个点 $(x_1, y_1)，(x_2, y_2)$ 可以得到一个直线的表达式 $y=mx+b$ 每次推进一个$x$，即每次 $x=x+1$，然后计算 $y=mx+b$ 的值，每次要进行取整； 如果 $m&gt;1$，那么可以选择每次将 $y$ 推进1格。 通常来说，DDA对上述过程做了一定的优化，每次不需要都计算 $y=mx+b$ 了，而是选择如下的公式计算： x_{k+1}=x_k+1；\\ y_{k+1}=y_k+m；到了 $m&gt;1$ 时就换成 $x_{k+1}=x_k+\frac{1}{m}$ 就好了，计算出结果以后取整作为像素点的坐标值。 看起来好了很多，但是还是要涉及到浮点数的运算，还有不少的取整操作，对于计算机来说实在是有点困难（因为会算的很多，浮点总是要慢一些的，还会涉及到一定的舍入误差累计）。 Bresenham算法感谢Bresenham老爷子提出的这个Bresenham算法，现在这基本上是所有直线算法的标准了，一般都会直接集成到硬件里。 Bresenham 直线算法原理先上一张图 可以看出来，每次选下一个点都是在 $(x_k+1, y_k+1)$ 和 $(x_k + 1, y_k)$ 之间选取，到底选哪个要看直线到底在这个x坐标下，离哪个更近一些。 我们把上下的距离分别标注为 $ d{upper} $ 和 $d{lower}$ ，当下边比较大的时候，就要选取上边的点，所以我们让他们相减，代入直线公式可以得到 d_{lower} - d_{upper} = 2m(x_i + 1) - 2\overline{y_i} + 2B - 1我们已经知道了 $\Delta x = x{end} - x{start} $ 是一个正值，所以我们可以把这个乘到上式，不会影响正负。 p_i = 2\Delta y \cdot x_i - 2\Delta x\cdot \overline{y_i} + c 这里 $\Delta x= x{end} - x{start}， \Delta y = y{end} - y{start}，m=\Delta y/ \Delta x$ ​ $c=(2B-1)\Delta x + 2 \Delta y$； 然后我们可以代入算出来 \begin{align} \mathrm { p } _ { 0 } &= 2 \Delta \mathrm { y } \bullet x _ { 0 } - 2 \mathrm { x } \bullet \overline { y } _ { 0 } + ( 2 B - 1 ) \Delta x + 2 \Delta y \\ &= 2 \Delta y \bullet x _ { 0 } - 2 \left( \Delta y \bullet x _ { 0 } + B \bullet \Delta x \right) + ( 2 B - 1 ) \Delta x + 2 \Delta y \\ &= 2 \Delta y - \Delta x \end{align}第二步代入了直线方程 要注意这个公式只有 $p_0​$ 可以这样推导出来，因为 $\overline {y_0} = mx_0 + B​$，而其他的 $y_i​$ 就不能这么简单的算出来了。 $\overline{y_i}$ 就是在 $i$ 这个点处，光栅化以后的纵坐标的值 还可以进一步的化简 \begin{aligned} p_{i+1} - p_{i} & = \left( 2 \Delta y \bullet x _ { i + 1 } - 2 \Delta x \cdot \overline { y } _ { i + 1 } + c \right) - \left( 2 \Delta y \bullet x _ { i } - 2 \Delta x \bullet \overline { y } _ { i } + c \right) \\ & = 2 \Delta y - 2 \Delta x \left( \overline { y } _ { i + 1 } - \overline { y } _ { i } \right) \end{aligned} 这里如果 $pi \leq 0$，那么 $\overline {y{i+1}} - \overline{yi} = 0$，那么 $p{i+1} = p_{i} + 2 \Delta y$； 这里如果 $pi &gt; 0$，那么 $\overline {y{i+1}} - \overline{yi} = 1$，那么 $p{i+1} = p_{i} + 2 \Delta y - 2 \Delta x$； 简直是神器啊，得到这个以后就可以开始计算了，全是整数，不浮点不取整不舍入，还是拟合效果最棒的，贴一张图看个例子： Bresenham 直线算法实现 这里使用了几个标志量：flipY和flipXY，表示我们我们对输入数据做的不同的预处理，目的都是把输入的直线转换为一个简单的形式，可以直接应用x=x+1, y=...这样的规则。 其中： 首先判断起始点的x坐标要在终点的x坐标前，如果不符合，则交换两个点的坐标； flipY：应用的情况如下图 目的是将左上到右下的直线转换为左下到右上，就可以使用我们讨论的方法了； flipXY：应用的情况如下图： 此时将纵坐标跨度较长的直线转换为了横坐标跨度较长的直线，也就可以应用我们讨论的办法了； 流程结束后，将得到的直线坐标根据这两个flag进行变换，得到真正的坐标。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 生成线vector&lt;float&gt; genLinePoints(Point from, Point to) &#123; Points points; bool flipY = false, flipXY = false; int dx = abs(to.x - from.x); int dy = abs(to.y - from.y); if (from.x &gt; to.x) &#123; swap2(from, to); &#125; if (from.y &gt; to.y) &#123; flipY = true; from.y = -from.y; to.y = -to.y; &#125; if (dy &gt; dx) &#123; flipXY = true; swap2(from.x, from.y); swap2(to.x, to.y); &#125; dx = to.x - from.x; dy = to.y - from.y; printf("%d, %d\n", dx, dy); // 意味着要使用 x 作为 +1 更新的坐标 vector&lt;int&gt; p(dx, 2 * dy - dx); points.push_back(from); for (int i = 1; i &lt; dx; i++) &#123; if (p[i - 1] &lt;= 0) &#123; p[i] = p[i - 1] + 2 * dy; &#125; else &#123; p[i] = p[i - 1] + 2 * dy - 2 * dx; &#125; if (p[i] &gt; 0) &#123; points.push_back(Point(from.x + i, points[i - 1].y + 1)); &#125; else &#123; points.push_back(Point(from.x + i, points[i - 1].y)); &#125; &#125; points.push_back(to); if (flipXY) &#123; for (int i = 0; i &lt; points.size(); i++) &#123; swap2(points[i].x, points[i].y); &#125; &#125; if (flipY) &#123; for (int i = 0; i &lt; points.size(); i++) &#123; points[i].y = -points[i].y; &#125; &#125; return pointsToFloat3(points);&#125; Bresenham 算法绘制三角形就是使用 Bresenham 算法画三条线，结果如下： Bresenham 算法画圆算法原理概述画圆和画直线的思路差不多，具体可以看https://en.wikipedia.org/wiki/Midpoint_circle_algorithm 同时要注意只需要画1/8圆就可以了，其他的部分可以对称过去。 起始的 $d = 3 - (2 * r)$，每次 $x = x + 1$，计算 $d$ 而得到 $y$ 坐标的值。 算法流程如下： 代码实现12345678910111213141516171819202122// 生成圆vector&lt;float&gt; genCirclePositions(Point centre, int radius) &#123; vector&lt;Point&gt; pv; int x = 0, y = radius, d = 3 - (2 * radius); auto eightPoints = circle8(centre, x, y); pv.insert(pv.end(), eightPoints.begin(), eightPoints.end()); while (x &lt; y) &#123; if (d &lt; 0) &#123; d = d + 4 * x + 6; &#125; else &#123; d = d + 4 * (x - y) + 10; y--; &#125; x++; auto eightPoints = circle8(centre, x, y); pv.insert(pv.end(), eightPoints.begin(), eightPoints.end()); &#125; auto data = pointsToFloat3(pv); return data;&#125; 实验结果 Edge Equation 三角形填充算法Edge Equation 算法原理概述三角形的填充使用Edge Equation算法，具体实现流程如下： 计算得到一个矩形框，如下图黄色部分，将三角形全部包括进去； 对矩形框内每个点进行计算，判断其是否在三角形的内部，如果在内部则进行渲染，否则不进行渲染； 这一步使用的是简单的直线方程进行计算，首先我们可以得到两点的直线方程为： (y_1 - y_2)x+(x_2 - x_1)y+x_1 y_2 - x_2 y_1 = 0对每个点应用该公式，判断其正负性，则可以判断是否在三角形内部； 具体使用时可能难以判断其正负性那个是在内部，可以使用第三个点辅助判断，与第三个点带入方程的符号相一致的是在三角内部的点，否则是在三角外部的点； 伪代码如下： Edge Equation算法实现1234567891011121314151617181920212223242526272829303132333435std::function&lt;bool(int x, int y)&gt; genLineEquation(Point p1, Point p2, Point p3) &#123; return [=](int x, int y) -&gt; bool &#123; auto lf = [&amp;](int x, int y) &#123; return (p1.y - p2.y) * x + (p2.x - p1.x) * y + (p1.x * p2.y - p2.x * p1.y); &#125;; if (lf(p3.x, p3.y) &gt;= 0) &#123; return lf(x, y) &gt;= 0; &#125; else &#123; return lf(x, y) &lt;= 0; &#125; &#125;;&#125;;// 生成三角形，通过Edge Eqution算法vector&lt;float&gt; genFilledTriPoints(Point p1, Point p2, Point p3) &#123; vector&lt;Point&gt; points; int maxx = max(p1.x, p2.x, p3.x), maxy = max(p1.y, p2.y, p3.y), minx = min(p1.x, p2.x, p3.x), miny = min(p1.y, p2.y, p3.y); auto l1f = genLineEquation(p2, p1, p3); auto l2f = genLineEquation(p3, p2, p1); auto l3f = genLineEquation(p3, p1, p2); for (int i = minx; i &lt; maxx; i++) &#123; for (int j = miny; j &lt; maxy; j++) &#123; bool inside = l1f(i, j) &amp;&amp; l2f(i, j) &amp;&amp; l3f(i, j); if (inside) &#123; points.push_back(Point(i, j)); &#125; &#125; &#125; return pointsToFloat3(points);&#125; 实验结果]]></content>
      <categories>
        <category>CG</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业1]]></title>
    <url>%2Fposts%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A1-2019-03-12%2F</url>
    <content type="text"><![CDATA[系统分析与设计的第一次作业 系统分析与设计作业 1简答1. 软件工程的定义首先翻译一下来自Wikipedia的定义：软件工程是进行软件开发，操作和维护的一种系统化，规范化，可量化的方法，是工程实践在软件开发上的应用和研究。按照我自己的理解，软件工程就是对于软件开发的每一个步骤（开发，操作，维护，成本……）的一个全方位的考量，是管理一款软件全部生产流程的学科。 2. 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法 本质原因：随着计算机的发展，软件的需求越来越复杂，软件规模变得越来越大，计算能力依照摩尔定律进行提升，因此落后的软件生产方式无法控制满足这样的需求，因此产生了软件危机； 表现：比如软件开发进度难以预测，软件开发成本难以控制，用户对产品功能难以满足，软件产品质量无法保证，软件产品难以维护，软件缺少适当的文档资料等； 客服软件危机的方法：首先要引入先进的管理办法，这就是软件工程要学习的内容； 3. 软件生命周期就是对软件开发的各个过程进行了划分，主要可以划分为以下的几个阶段： 可行性分析与计划，需求分析，设计，编码实现，测试，运行和维护 人们又建立了不同的软件生命周期模型，比如瀑布法，划分了五个过程（Requirement需求；Design设计；Implementation编码实现；Verification验证测试；Maintenance维护），其它的模型有不同的划分； 4. SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明）2 软件工程实践中的知识领域 2.1 Software Requirements 软件要求涉及软件要求的启发、协商、分析、规范和验证。软件行业普遍承认, 当软件工程项目执行不力时, 这些项目就会非常脆弱。软件需求表达了对软件产品的需求和限制, 这些需求和约束有助于解决一些现实世界的问题。 2.2 Software Design 软件设计设计系统或组件的体系结构、组件、接口和其他特征的过程和结果 (ieee 1991)。 2.3 Software Construction 软件构建指通过详细设计、编码、单元测试、集成测试、调试和验证相结合的方式, 详细创建工作软件。 2.4 Software Testing 软件测试测试是一项通过识别缺陷来评估产品质量和改进产品质量的活动。软件测试涉及针对有限的测试用例集上的预期行为对程序的行为进行动态验证。 2.5 Software Maintenance 软件维护软件维护包括增强现有功能、调整软件以在新的和改进的操作环境中运行以及纠正缺陷。 2.6 Software Configuration Management 软件配置管理软件配置管理 (scm) 是在不同时间点识别系统配置的学科, 目的是系统地控制对配置的更改, 以及维护完整性和在整个软件生命周期中配置的可追溯性。 2.7 Software Engineering Management 软件工程管理软件工程管理包括规划、协调、测量、报告和控制项目或计划, 以确保软件的开发和维护是系统的、有纪律的和量化的。 2.8 Software Engineering Process 软件工程过程软件工程负责软件生命周期过程的定义、实施、评估、测量、管理和改进。 2.9 Software Engineering Models and Methods 软件工程模型与方法软件工程模型和方法 ka 解决了包含多个生命周期阶段的方法。 2.10 Software Quality 软件质量软件质量是一个普遍存在的软件生命周期问题。 2.11 Software Engineering Professional Practice 软件工程专业实践软件工程专业实践涉及软件工程师以专业、负责和合乎道德的方式实践软件工程所必须具备的知识、技能和态度。 3 Knowledge Areas Characterizing the Educational Requirements of Software Engineering 软件工程教育要求知识领域 3.1 Software Engineering Economics 软件工程经济学软件工程经济学负责在业务环境中做出决策, 使技术决策与组织的业务目标保持一致。 3.2 Computing Foundations 计算基础涵盖了提供软件工程实践所需的计算背景的基本主题。所涉及的主题包括问题解决技术、抽象、算法和复杂性、编程基础知识、并行和分布式计算的基础知识、计算机组织、操作系统和网络通信。 3.3 Mathematical Foundations 数学基础为软件工程的实践提供必要的数学背景； 3.4 Engineering Foundations 工程基础涵盖了为软件工程实践提供必要的工程背景的基本主题。 5. 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。成熟度级别 1: 初始 Initial不可预测和被动。工作已经完成, 但经常被推迟和超出预算。 成熟度级别 2: 托管 Managed在项目级别上管理。项目是有计划的、执行的、测量的和控制的。 成熟度级别 3: 定义 Defined主动, 而不是反应。全组织标准为项目、计划和投资组合提供指导。 成熟度级别 4: 量化管理 Quantitatively Managed测量和控制。本组织以数据为导向, 实现量化的业绩改进目标, 这些目标是可预测的, 并与之保持一致, 以满足内部和外部利益攸关方的需求。 成熟度级别 5: 优化 Optimizing稳定灵活。本组织注重持续改进, 旨在对机遇和变化进行支点和反应。组织的稳定性为敏捷性和创新提供了一个平台。 6. 用自己语言简述 SWEBok 或 CMMI （约200字）SWEBok：是IEEE组织的一个项目，软件工程知识体系指南。在这本指南中，IEEE首次建立了软件工程领域知识体系的基线，他们的工作满足了部分想要促进该领域理论和实践的进展的想法。在这之前，社会上的相关工作受到了历史学科经验的指导，但没有受到一些遇到的问题或者解决方法的帮助。它是对过去几年不断发展和演变的知识体系的一个概略和指南，这个知识体系不是静态的，必须随着软件工程的成熟而发展和演变，是软件工程基础设施中一个有价值的元素。 CMMI：全称是Capability Maturity Model Integration，即能力成熟度模型集成，其目的是帮助软件企业对软件工程过程进行管理和改进，增强开发与改进能力，从而能按时地、不超预算地开发出高质量的软件。其所依据的想法是：只要集中精力持续努力去建立有效的软件工程过程的基础结构，不断进行管理的实践和过程的改进，就可以克服软件开发中的困难。CMMI为改进一个组织的各种过程提供了一个单一的集成化框架，新的集成模型框架消除了各个模型的不一致性，减少了模型间的重复，增加透明度和理解，建立了一个自动的、可扩展的框架。因而能够从总体上改进组织的质量和效率。CMMI主要关注点就是成本效益、明确重点、过程集中和灵活性四个方面。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImGui入门笔记]]></title>
    <url>%2Fposts%2FImGui%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2019-03-10%2F</url>
    <content type="text"><![CDATA[这个玩意资料有点少，所以记录一下怎么开始上路，怎么爬一些坑，供自己和别人参考…… 怎么学这东西这可能是最大的问题了。 首先肯定要看它的官网，https://github.com/ocornut/imgui； 然后你会发现官网的这个RAEDME是个蛇皮没什么大用…… 然后我们发现目录下有个doc目录，进去发现也没什么用，真的是…… 有用的部分在example文件夹下， 比如这个示例！这就是我们学习的最重要的资源了！！！ 安装 首先git clone这个仓库 1git clone https://github.com/ocornut/imgui 然后把目录下的所有.h和.cpp文件都复制到自己的项目里 就这些东西，全部复制进去就对了； 还没完，打开examples文件夹，进去可以看到有好多imgui_impl_***.*，挑选自己需要的那些都复制到自己的项目里；比如我的目录下 错了可能是复制多了几项，来回删一删试试……还是比较迷的…… 然后就可以跑了，跑一下发现报错gl3w.h没有，当然了用的不是这个库当然就没有了……打开imgui_impl_opengl3.h，把这里改成你所使用的库 应该是都在这几个里边了，我使用的是glad，所以使用了glad的宏； 跑跑第一个程序不出意外的话应该是可以跑了，我们可以直接把仓库的examples文件夹里，合适自己的用的那个复制过来试试，比如我用的是glfw+openGL3，我复制了这里的代码（路径是/examples/example_glfw_opengl3/main.cpp），这就可以点点画画了。]]></content>
      <categories>
        <category>ImGui</category>
      </categories>
      <tags>
        <tag>ImGui</tag>
        <tag>入门笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL入门笔记]]></title>
    <url>%2Fposts%2FOpenGL%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2019-03-09%2F</url>
    <content type="text"><![CDATA[学习OpenGL还是挺难理解的，入门路上遇到了一些问题，在这里埋埋坑，希望可以帮助一些后来者 主要的学习来源是learnopengl的中文教程官网； 基本不会写到具体的过程，具体的过程在教程官网上已经非常详细了，所以这里基本上会写成类似于Q&amp;A，或者记录一些不理解的地方的形式…… 链接顶点属性EBO/IBO，索引这里讲的不错，https://blog.csdn.net/fenghen777/article/details/46981781 我们还是按照官网的教程来讲，官网给了这样一个例子，要画一个4边形； 12345678910float vertices[] = &#123; // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;; 为什么是6个点呢，因为OpenGL是按照三角形来渲染的，所以一个四边形就要分为两个三角形来绘制。 这样就造成了一个问题，有两个点是重复的，我们当然不想重复，不优雅啊！（当然最重要的问题是会造成多余的存储开销，多存了50%的点，如果三角形更多的话，这个开销还是很可观的）。 所以我们考虑一个新的方式，就是只输入4个顶点，然后我们指定绘制的顺序，就是这样： 1234567891011float vertices[] = &#123; 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;;unsigned int indices[] = &#123; // 注意索引从0开始! 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形&#125;; 不知道你们怎么样，我第一次看是有点懵，仔细看了一下大概是这样的： 明白了吧，这个顶点的顺序就是顶点数组里的顺序。]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 264. Ugly Number II]]></title>
    <url>%2Fposts%2FLeetcode%20264.%20Ugly%20Number%20II-2019-03-07%2F</url>
    <content type="text"><![CDATA[Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n = 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Solution123456789101112131415class Solution &#123;public: int nthUglyNumber(int n) &#123; int i2 = 0, i3 = 0, i5 = 0; vector&lt;int&gt; dp &#123;1&#125;; for (int i = 0; i &lt; n; i++) &#123; int m = min( min(dp[i2]*2, dp[i3]*3), dp[i5]*5 ); dp.push_back(m); if (m == dp[i2]*2) i2++; if (m == dp[i3]*3) i3++; if (m == dp[i5]*5) i5++; &#125; return dp[n-1]; &#125;&#125;; 题解应该大家看着还是挺迷茫的，我们从题目开始思考，要找的是质因数只有2、3、5的数，那么我们可以产生两种思路，一种是验证的思路，对于每个数进行验证，判断他是否有2、3、5之外的质因子；或者是采用构造的思路，从某个数开始构造满足这个条件的数字。 明显第一种思路耗时很久，毕竟现在还是没有很好地判断因子分解的算法。从另一种思路出发，我们可以这样考虑：所有以2、3、5为因子的数相乘并不会产生其他的素数作为因子，我们可以简单地推导一下 很明显素数 $p$ 和 $q$ 相乘时，$pq$不存在其他的素数作为它的因子； $ p^i q^j $明显也没有其他素数作为因子 因此这个算法应该是成立的！ 因此，又为了排序的目的，我们逐个取最小值产生ugly number的数组。 如下： 1234567t2 = 0, t3 = 0, t5 = 0 uglg numbers [0] = 1for i from 1 to n uglg numbers [i] = min( uglg numbers [t2], uglg numbers [t3], uglg numbers [t5])return uglg numbers [n-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 152. Maximum Product Subarray]]></title>
    <url>%2Fposts%2FLeetcode%20152.%20Maximum%20Product%20Subarray-2019-03-07%2F</url>
    <content type="text"><![CDATA[题目Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 题解这道题的目标是找到最大乘积的子串，还是比较复杂的，看题目就感觉是一道动态规划，我们首先肯定想到的是这样的递推公式： maxProduct[i] = max\{ maxProduct[i-1] * nums[i] , nums[i] \}其中，maxProduct[i]表示以第i位结尾的所有子串的最大乘积，所以要么选择nums[i]乘进去得到更大的值，要么不选择它，而是从他开始重新计算一个子串。 这个解法会遇到一个问题，比如[1, 2, -3, -5]，在面对两个负数的时候，我们的解法遇到-3时就会把它去掉而在-3的地方重新计算。即，maxProduct[i] = nums[i] = 3 ，但是，如果我们保留maxProduct[2] = maxProduct[i-1]*nums[i] = -6，那么我们在计算到-5时就可以得到更大的值30。 考虑这样的情况，我们要改造我们的算法，我们在保留最大的乘积的同时，保留一个最小的负值，期望这个负值可以让最终得到另一个负值时可以得到更大的计算结果。即： 当nums[i]为正值时： postiveMax[i] = max \{ nums[i] , postiveMax[i-1]*nums[i] \} \\ negtiveMin[i] = min \{ nums[i] , negtiveMin[i-1]*nums[i] \}很简单，最小的负值就是当前的最小负值乘上nums[i]或者本身（重新开始），最大的正值也就是当前的最大正值乘上nums[i]或者本身（重新开始）。 当nums[i]为负值时： postiveMax[i] = max\{ nums[i] , negtiveMin[i-1]*nums[i] \} \\ negtiveMin[i] = min\{ nums[i] , postiveMax[i-1]*nums[i] \};此时，最大正值可以通过最大的负值乘以当前的负nums[i]得来，也就解决了上面的问题。 下面我们进行实现： Solution 112345678910111213141516171819class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int re = nums[0]; vector&lt;int&gt; postiveMax(nums); vector&lt;int&gt; negtiveMin(nums); for (int i = 1; i &lt; nums.size(); i++) &#123; if ( nums[i] &lt; 0 ) &#123; postiveMax[i] = max( nums[i] , negtiveMin[i-1]*nums[i] ); negtiveMin[i] = min( nums[i] , postiveMax[i-1]*nums[i] ); &#125; else &#123; postiveMax[i] = max( nums[i] , postiveMax[i-1]*nums[i] ); negtiveMin[i] = min( nums[i] , negtiveMin[i-1]*nums[i] ); &#125; re = max(re, postiveMax[i]); &#125; return re; &#125; &#125;; 还可以进行一些小小的优化使得代码量更加减少： 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int re = nums[0]; vector&lt;int&gt; postiveMax(nums), negtiveMin(nums); for (int i = 1; i &lt; nums.size(); i++) &#123; postiveMax[i] = max( postiveMax[i-1]*nums[i] , max( nums[i] , negtiveMin[i-1]*nums[i] ) ); negtiveMin[i] = min( negtiveMin[i-1]*nums[i] , min( nums[i] , postiveMax[i-1]*nums[i] ) ); re = max(re, postiveMax[i]); &#125; return re; &#125; &#125;; 把判断nums[i]正负性的一步去掉了，因为我们其实无需关心到底是取了哪一个，我们只要它拿到最小和最大即可了。 分析我们分析这里的复杂度，发现空间复杂度是O(n)，时间复杂度也是O(n)。 这个解法还是可以更加优化一下的，空间复杂度可以降为O(1)，即每次只保留前一次(max[i-1])的结果就好了， 不需要知道前(max[i-2, i-3, ...])的内容。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 97. Interleaving String]]></title>
    <url>%2Fposts%2FLeetcode%2097.%20Interleaving%20String-2019-03-07%2F</url>
    <content type="text"><![CDATA[Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 题解使用动态规划求解。 首先我们分解子问题。如果s3是s1和s2的交错字符串的话，那么一定有以下的一种情况 s3的最后一位和s2的最后一位相同，此时s3前边的子串(除去最后一位)一定是s2的前边的子串与s1的交错字符串。 s3的最后一位和s1的最后一位相同，此时s3前边的子串(除去最后一位)一定是s1的前边的子串与s2的交错字符串。 这个很容易想到，因为构造出交错的字符串的时候肯定是从s1选1个char，又从s2选1个char，所以如果当前是交错的串的话，去掉最后一位相同的位之后，前边的串肯定也是根据这个规则构造来的，所以也是交错的字符串。 因此我们可以写出迭代方程： length·of·s3 = l \\ length·of·s2 = n \\ length·of·s1 = m \\ isInterleave(s3[0...l]) = \\ (s3[l] == s2[n] ^ isInterleave(s1[0...m], s2[0...n-1], s3[0...l-1])) \\ or (s3[l] == s1[m] ^ isInterleave(s1[0...m-1], s2[0...n], s3[0...l-1])) \\基于此方程我们写出如下的解： Solution12345678910111213141516171819202122232425class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.length(), n = s2.length(), l = s3.length(); if (m + n != l) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); for (int i = 0; i &lt; m+1; i++) &#123; for (int j = 0; j &lt; n+1; j++) &#123; if (i == 0 &amp;&amp; j == 0) dp[0][0] = true; else if (i == 0) dp[i][j] = dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]; // when i = 0, j = 1 // dp[0][1] = dp[0][0] and s2[1] == s3[1] else if (j == 0) dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]; // when i = 1, j = 0 // dp[1][0] = dp[0][0] and s1[1] == s3[1] else dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]); // when i = 1, j = 1 // dp[1][1] = // | dp[0][1] &amp;&amp; s1[1] == s3[2] // | dp[1][0] &amp;&amp; s2[1] == s3[1] &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 87. Scramble String]]></title>
    <url>%2Fposts%2FLeetCode%2087.%20Scramble%20String-2019-03-07%2F</url>
    <content type="text"><![CDATA[题目Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = &quot;great&quot;: 1234567 great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. 1234567 rgeat / \ rg eat / \ / \r g e at / \ a t We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. 1234567 rgtae / \ rg tae / \ / \r g ta e / \ t a We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: 12Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true Example 2: 12Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false Solution 283 / 283 test cases passed. Status: Accepted Runtime: 0 ms 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1==s2) return true; int len = s1.length(); int count[26] = &#123;0&#125;; for(int i=0; i&lt;len; i++) &#123; count[s1[i]-'a']++; count[s2[i]-'a']--; &#125; for(int i=0; i&lt;26; i++) &#123; if(count[i]!=0) return false; &#125; for(int i=1; i&lt;=len-1; i++) &#123; if( isScramble(s1.substr(0,i), s2.substr(0,i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if( isScramble(s1.substr(0,i), s2.substr(len-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0,len-i))) return true; &#125; return false; &#125;&#125;; 题解可以分析一下，两个串是 isScramble 的话，那么其中一个串，是通过另一个串进行多次的交换得来的。交换可以交换两个相邻的字符，也可以交换相邻的子串。 类似的我们可以分析，如果两个串满足这个性质，那么我们可以把它们都分为两个长度相同的部分（前i位，记为s11, s21，和后n-i位，记为s12, s22）。 思路很简单，如果两个串是 isScramble 的话，那么肯定是上下相对应，或者交换后相对应（即满足isScramble的)。也就是说，我们可以通过分别验证这两个性质来确认其是否满足条件，只要有一个满足，那么它就是isScramble的。 在这样的思路上我们可以做一些优化，比如将每次递归的结果存起来，使得递归到已经算过的子串的时候可以直接获取答案而不是再次进行计算。 但是在实际使用中发现优化后的代码运行速度并不快，我推测这是因为当前递归程序的重复计算已经被消除了，相同的子串不会进行多次判断，因而完全无需进行记忆性的递归。 分析 时间复杂度： 这是一个递归算法，每次循环n次，最多递归n层，时间复杂度为O(n!)，这是最坏情况]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2Fhello-world-2019-03-07%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake]]></content>
  </entry>
</search>
