---
title: 终止检测算法
date: 2019-07-07 15:21:33
tags:
- 分布式
- 算法
category: 分布式
---

记录了两个终止检测算法

* 基于快照的终止检测算法
* 基于生成树的终止检测算法

<!--more-->



## 终止检测算法概述



### 为什么需要终止检测算法呢？

因为在分布式环境下，没有一个集中的控制点，也就是说没有一个节点说“好，现在所有人都结束了，我们程序也可以结束了”（大概相当于`join`的作用）。

### 什么时候可以称为终止了呢？

* 任意一个进程都结束了；
* 任意两个进程之间不存在正在发送（还未接收）的消息

### 基本思路

进程分为空闲和活跃两个状态，进程结束时变成空闲，接收到消息时变成活跃；当每个进程都空闲之后，程序就结束了；



## 基于快照的终止检测算法

### 算法思路

每个进程变成空闲时，都开心的认为自己就是那个最后结束的进程了。它想要验证这个事实，因此向全局广播一条收集快照的消息，希望可以收集到一个全局快照。在这个过程里，如果遇到了未结束的进程，那么宣告本次收集快照的行为失败了。所有，只有真正的最后一个进程才能收集到全局的快照。

### 算法流程

首先，每个进程维护一个逻辑时钟`x`，用`k`记录获取快照的进程；

几个规则

* R1：`i`被激活，那么给随便选的一个进程`j`发送一个消息`B(x)`，附带自己的逻辑时钟`x`；

* R2：`i`收到一个`B(x')`的消息，那么更新自己的时钟`x=x'+1`，尝试着把自己激活；

* R3：`i`变空闲，那么更新一下逻辑时钟`x=x+1`，然后将收集快照的进程设为自己`k=i`，然后向所有进程广播收集快照的消息`R(x, k)`，

* R4：收到了快照请求`R(x', k')`，判断是否要相应

  判断`(x', k') > (x, k) && i is idle`，那么就快照记录当前进程信息

  如果不满足这个要求，那么就当没收到这个请求；
  
  如果当前进程处于激活态，那就`x=max(x, x')`



bx大佬写的明白啊，https://blog.csdn.net/huangbx_tx/article/details/94917026

`x`标记的就是自己的时间，如果自己是最后的进程，那么自己的x一定是最大的；

如果一个进程收到了`B(x')`，那么就意味着，这个进程发现自己是比`B(x')`还靠后的进程，所以更新自己的`x=x'+1`，最主要的目的是表明：发送方的`x'`不是最后一个进程（所以不需要max）；

如果收到了快照请求`R(x', k')`，发现请求方比自己靠后，那就快照，不是的话就不照；并且自己的`x=max(x, x')`，表明自己快照过了；